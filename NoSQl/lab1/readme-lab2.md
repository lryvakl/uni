У мене є таблиця session_results, яка зберігає фінальний результат гонки (хто яким приїхав). Але було б цікаво і доречно ще зберігати телеметрію. Кожен пілот проїжджає 40-70 кіл. Кожне коло має 3 сектори. Кожну мілісекунду датчики шлють телеметрію (швидкість, шини, оберти).

---

### Чому SQL тут може бути не найкращим ріщенням:
**Об'єм даних:** 20 машин * 70 кіл = 1400 записів про кола за гонку. Якщо брати телеметрію (100 разів на сек) це мільйони записів. SQL індекси будуть сповільнювати вставку

**Структура даних:** Щоб отримати повну картину заїзду пілота в SQL, потрібно виконувати затратні операції `JOIN` між таблицями `sessions, drivers` та `laps`

**Жорстка схема:** Параметри телеметрії можуть змінюватися (нові датчики), що вимагає `ALTER TABLE` в SQL, тоді як NoSQL дозволяє гнучку структуру.

**Читання**: Щоб намалювати графік темпу пілота в SQL, треба робити `SELECT * FROM laps WHERE ....` Це сканування багатьох рядків. У Document DB можна зберігати всі кола однієї гонки як один вкладений масив у документі пілота

Томку я додала використання **MongoDB** для телеметрії та використала патерн Embedding, замість того, щоб створювати тисячі рядків, створю колекцію `race_telemetry` де один документ містить всю історію заїзду одного пілота (вкладений масив кіл)

---
Вимога про декілька таблиць: один документ MongoDB агрегує дані, які в SQL нормалізовані у три сутності: ідентифікатори з `sessions` (таблиця Sessions) та `drivers` (таблиця Drivers) + масив даних з таблиці `lap_times` (таблиця lap_times)

---

Основна база PostgreSQL залишається "Single Source of Truth" для критичних даних (Users, Orders, Official Results).
MongoDB додається для зберігання об'ємних даних про хід гонки (а саме телеметрія), розвантажуючи SQL.

---

## Тестування та порівняння результатів:
`src/benchmark.ts`:

```
STARTING BENCHMARK: 20 drivers, 50 laps each.
--------------------------------------------------
SQL Write (INSERT 1000 rows): 127.008ms
NoSQL Write (INSERT 20 docs): 67.247ms
--------------------------------------------------
SQL Read (SELECT 50 rows): 3.704ms
NoSQL Read (Find 1 doc): 18.491ms
```
 **Запис**:

NoSQL швидший у ~2 рази.  
Виконалось 1000 окремих `INSERT` запитів. Кожен запит це мережева затримка, перевірка структури таблиці, перевірка типів даних і оновлення B-Tree індексу (`idx_lap_times_search`) 1000 разів.

NoSQL: відправилось всього 20 об'ємних документів. MongoDB отримала їх і записала на диск майже миттєво.

Тобто для цієї ситуації NoSQL очевидно буде набагато продуктивнішим вибором і при масштабуванні до реальних об'ємів (мільйони записів телеметрії) розрив буде зростати експоненціально на користь MongoDB.

**Читання:**

NoSQL виявиллось повільнишим. 50 рядків це досить малий об'єм даних, тому PostgreSQL дістала їх з оперативної пам'яті дуже швидко. Так як я використовую бібліотеку Mongoose, вона витрачає час на те, щоб перетворити JSON з бази на повноцінний JavaScript об'єкт з методами.
Для простих вибірок SQL дуже швидкий, але якби треба було витягнути історію за 10 років, MongoDB могла б виграти за рахунок того, що їй не треба збирати рядки по всій таблиці, вона просто бере один готовий документ.

## NoSql база іншого типу:
Я обрала **Redis** для Real-time фіч (таблиця лідерів), де потрібна миттєва реакція.
`src/redis_demo.ts`:
```
 --- REDIS LIVE LEADERBOARD DEMO ---
1. Updating points...
   Data added.

2. Getting TOP-3 Drivers:
   #1 Verstappen: 350 pts
   #2 Leclerc: 300 pts
   #3 Norris: 280 pts

3. Lando Norris wins! (+25 pts)
   Norris is now at position #2 with 305 pts 
```
**Аналіз результату:**

 1. **Початковий стан:** Redis зберіг список пілотів у Sorted Set (впорядкована множина):
* Verstappen: 350
* Leclerc: 300
* Norris: 280
* Redis автоматично відсортував їх у пам'яті

2. **Операція:** виконали `zIncrBy(..., 25, 'Norris')`.
Це атомарна операція

3. **Результат:** Norris отримав 305 балів (280 + 25).
Redis: перемістив Норріса з 3-го місця на 2-ге (обійшовши Леклера, у якого 300). Індекс оновився в реальному часі